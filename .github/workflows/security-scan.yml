# .github/workflows/security-scan.yml

name: Security Scan

# This workflow runs on every push to any branch
on: [push]

jobs:
  # .github/workflows/security-scan.yml

  bandit-scan:
    name: Bandit Scan
    runs-on: ubuntu-latest
    steps:
      # This step USES an action
      - name: Check out code
        uses: actions/checkout@v4

      # This step USES an action
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      # This step RUNS a command
      - name: Install Bandit and jq
        run: |
          pip install bandit
          sudo apt-get update && sudo apt-get install -y jq

      # This step RUNS a command
      - name: Run Bandit and Generate Report
        run: bandit -r . -f json -o bandit-report.json --exit-zero

      # This step RUNS a command
      - name: Summarize Report with Gemini
        run: |
          REPORT_AS_STRING=$(cat bandit-report.json)

          # This new prompt provides a strict template for the AI to follow.
          PROMPT="You are a cybersecurity expert. Your task is to analyze this Bandit JSON report and provide a security summary. The output MUST follow this format exactly, listing each issue under its severity level:

          ## üö® High Severity
          **Error Name:** [The 'test_name' from the report]
          **Error Message:** [The 'issue_text' from the report]

          ---
          
          ## ‚ö†Ô∏è Medium Severity
          **Error Name:** [The 'test_name' from the report]
          **Error Message:** [The 'issue_text' from the report]
          
          ---

          ## ‚úÖ Low Severity
          **Error Name:** [The 'test_name' from the report]
          **Error Message:** [The 'issue_text' from the report]

          If a severity level has no issues, state 'No issues found.' under that heading.
          Do not add any other text, summary, or explanation outside of this format.
          
          Here is the Bandit JSON report:
          "

          # Use jq to safely build the final JSON payload with the new prompt.
          PAYLOAD=$(jq -n --arg report "$REPORT_AS_STRING" --arg prompt "$PROMPT" '{
              "contents": [{
                  "parts": [{
                      "text": ($prompt + "\n\n" + $report)
                  }]
              }]
          }')
          
          # Call the Gemini API (v1beta) with the correctly formatted payload.
          curl -X POST \
               -H "Content-Type: application/json" \
               "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${{ secrets.GEMINI_API_KEY }}" \
               -d "$PAYLOAD" | jq .
